

### 1. Sorting Algorithms
- Quick Sort and Merge Sort: Important for understanding divide-and-conquer strategies.
- Heap Sort: Helps grasp the concepts of heaps and priority queues.
- Counting Sort and Radix Sort: Useful for cases where data is within a limited range.


### 2. Search Algorithms
- Binary Search: Key for any problem requiring efficient searching in sorted data.
- Depth-First Search (DFS) and Breadth-First Search (BFS): Essential for graph traversal and tree operations.


### 3. Graph Algorithms
- Dijkstra’s Algorithm and A*: For shortest path problems.
- Bellman-Ford: Handles graphs with negative weights.
- Kruskal’s and Prim’s Algorithms: Used for finding Minimum Spanning Trees.


### 4. Dynamic Programming (DP)
- Knapsack and Subset Sum: Fundamental to understanding DP techniques.
- Longest Common Subsequence (LCS) and Longest Increasing Subsequence (LIS): Cover subproblems and overlapping subproblems.
- Floyd-Warshall: All-pairs shortest paths in a graph, which uses DP.


### 5. Greedy Algorithms
- Huffman Coding: Used in data compression.
- Interval Scheduling and Activity Selection: Core greedy problems often used to understand optimal solutions.
- Coin Change (Greedy version): Useful for mastering greedy choice properties.


### 6. Tree Algorithms
- Binary Search Trees (BST): Understand how to implement and use BST operations.
- AVL Trees and Red-Black Trees: Key for self-balancing tree concepts.
- Trie: Often used for prefix matching and efficient search.


### 7. Backtracking and Recursion
- N-Queens and Sudoku Solver: Classic backtracking problems.
- Permutations and Subsets: Useful for combinatorial problems and recursion.


### 8. Hashing and Data Structures
- Hash Maps and Hash Sets: Understanding hashing is essential for efficient lookups.
- Linked Lists, Stacks, Queues, and Deques: Basics that appear in more complex problems.


### 9. Bit Manipulation
- Common for problems involving low-level operations, optimization, and constraints fitting within integer limits.